//
// Created by Diaz, Diego on 14.9.2022.
//
#include<iostream>
#include <vector>
#include "bwt_io.h"

#define INT_CEIL(a,b) (a>0? 1+(a-1)/b : 0)

int main(int argc, char** argv) {

    if (argc != 5) {
        std::cout << "usage: ./split_runs file.rlbwt output_file bits n\n\n"
                     "file.rlbwt: the BCR BWT file generated by grlBWT\n"
                     "bits:       maximum number of bits that the runs can use\n"
                     "n:          partition the runs into blocks so that the cumulative sum for the run lengths of each block is precisely n. 0 means no partition\n"
                     "output file: file storing the new encoding for file.rlbwt"<< std::endl;
        exit(0);
    }

    errno = 0;
    std::string input_file = std::string(argv[1]);
    char *endptr;
    long bits = strtol(argv[2], &endptr, 10);
    size_t block_size = strtol(argv[3], &endptr, 10);
    size_t n_syms=0;
    std::string output_file = std::string(argv[4]);

    assert(bits<64);
    size_t max_length= (1UL<<size_t(bits))-1UL;
    std::cout<<"Maximum size allowed for the runs "<<max_length<<std::endl;
    std::cout<<"Block size "<<block_size<<std::endl;

    bwt_buff_reader bwt_reader(input_file);
    size_t sym=0, len=0, tmp_len;

    bwt_buff_writer bwt_writer(output_file,
                               std::ios::out,
                               bwt_reader.bytes_per_rsym(),
                               INT_CEIL(bits, 8));

    std::cout<<"Splitting the runs in the BWT"<<std::endl;
    size_t tot_runs=0, acc_block=0, diff, o_splits=0, b_splits=0, block_runs=0, max_n_runs=0;

    std::vector<size_t> runs_per_block(block_size, 0);

    for(size_t i=0;i<bwt_reader.size();i++){

        bwt_reader.read_run(i, sym, len);
        n_syms +=len;

        while(len>max_length){
            len-=max_length;
            tmp_len=max_length;
            if(block_size>0){
                while((acc_block+tmp_len)>block_size){
                    diff = (acc_block + tmp_len) - block_size;
                    tmp_len -= diff;
                    //append extra run of length tmp_len
                    bwt_writer.push_back(sym, tmp_len);
                    tot_runs++;
                    b_splits++;
                    block_runs++;
                    runs_per_block[block_runs]++;
                    if(block_runs>max_n_runs) max_n_runs=block_runs;
                    assert((acc_block + tmp_len) == block_size);

                    tmp_len = diff;
                    acc_block = 0;
                    block_runs=0;
                }
            }
            assert((acc_block+tmp_len)<=block_size);
            //append extra run of length tmp_len
            bwt_writer.push_back(sym, tmp_len);
            tot_runs++;
            o_splits++;
            block_runs++;
            //runs_per_block[block_runs]++;
            acc_block +=tmp_len;
        }

        assert(len<=max_length);
        if(block_size>0){
            while((acc_block+len)>block_size){
                diff = (acc_block + len) - block_size;
                len -= diff;
                //append extra run of length len
                bwt_writer.push_back(sym, len);
                tot_runs++;
                b_splits++;
                block_runs++;
                runs_per_block[block_runs]++;
                if(block_runs>max_n_runs) max_n_runs=block_runs;
                assert((acc_block + len) == block_size);

                len = diff;
                acc_block = 0;
                block_runs = 0;
            }
        }

        assert(len<=max_length && (acc_block+len)<=block_size);
        //append run of length len
        bwt_writer.push_back(sym, len);
        tot_runs++;
        block_runs++;
        //runs_per_block[block_runs]++;
        acc_block+=len;
    }

    runs_per_block[block_runs]++;
    if(block_runs>max_n_runs) max_n_runs=block_runs;
    assert(acc_block<=block_size);

    size_t tot_blocks=0;
    for(unsigned long i : runs_per_block) tot_blocks+=i;
    assert(tot_blocks==INT_CEIL(n_syms, block_size));
    assert(max_n_runs<=block_size);

    bwt_reader.close();
    bwt_writer.close();

    std::cout<<"Number of blocks "<<INT_CEIL(n_syms, block_size)<<std::endl;
    std::cout<<"Max. number of runs in a block:  "<<max_n_runs<<std::endl;
    std::cout<<"Number of runs before: "<<bwt_reader.size()<<std::endl;
    std::cout<<"Number of runs now: "<<tot_runs<<std::endl;
    std::cout<<"  Overflow splits: "<<o_splits<<" ("<<(double(o_splits)/double(tot_runs))*100<<"%) "<<std::endl;
    std::cout<<"  Block boundary splits: "<<b_splits<<" ("<<(double(b_splits)/double(tot_runs))*100<<"%) "<<std::endl;
    std::cout<<"Distribution of runs per block:"<<std::endl;

    size_t q1=(tot_blocks+1)/4;
    size_t q2 = (tot_blocks+1)/2;
    size_t q3 = (3*(tot_blocks+1))/4;
    size_t res1=0, res2=0, res3=0;
    bool b_q1=false, b_q2=false, b_q3=false;
    size_t block_acc=0;
    std::string output_dist_file = output_file+".dist";
    std::ofstream ofs(output_dist_file);
    ofs <<"number_of_runs_in_a_block\tfreq\trelative_freq\tacc_freq"<<std::endl;
    size_t min_runs=0;
    for(size_t i=0;i<runs_per_block.size();i++){

        if(min_runs==0 && runs_per_block[i]!=0){
            min_runs = i;
        }

        block_acc+=runs_per_block[i];
        if(!b_q1 && block_acc > q1){
            //std::cout<<q1<<" q1:"<<i<<" "<<double(block_acc)/double(tot_blocks)<<std::endl;
            b_q1=true;
            res1=i;
        }

        if(!b_q2 && block_acc > q2){
            //std::cout<<q2<<" q2:"<<i<<" "<<double(block_acc)/double(tot_blocks)<<std::endl;
            res2=i;
            b_q2=true;
        }

        if(!b_q3 && block_acc > q3){
            //std::cout<<q3<<" q3:"<<i<<" "<<double(block_acc)/double(tot_blocks)<<std::endl;
            res3=i;
            b_q3=true;
        }
        if(i<=max_n_runs){
            ofs <<i<<"\t"<<runs_per_block[i]<<"\t"<<double(runs_per_block[i])/double(tot_blocks)<<"\t"<<double(block_acc)/double(tot_blocks)<<std::endl;
        }else{
            assert(runs_per_block[i]==0);
        }
    }
    ofs.close();
    std::cout<<"min_n_runs q1 q2 q3 upper_whisker max_n_runs"<<std::endl;
    std::cout<<min_runs<<" "<<res1<<" "<<res2<<" "<<res3<<" "<<(double(res3) + (double(res3-res1)*1.5))<<" "<<max_n_runs<<std::endl;
//    std::cout<<"min n_runs: "<<min_runs<<std::endl;
//    std::cout<<"q1: "<<res1<<std::endl;
//    std::cout<<"q2: "<<res2<<std::endl;
//    std::cout<<"q3: "<<res3<<std::endl;
//    std::cout<<"IQR: "<<res3-res1<<std::endl;
//    std::cout<<"upper whisker: "<<(double(res3) + (double(res3-res1)*1.5))<<std::endl;
//    std::cout<<"max n_runs: "<<max_n_runs<<std::endl;

    std::cout<<"Increase ratio "<<double(tot_runs)/double(bwt_reader.size())<<std::endl;
    std::cout<<"The new encoding of the BWT was stored in "<<output_file<<std::endl;

}
