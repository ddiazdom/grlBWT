//
// Created by Diaz, Diego on 14.9.2022.
//
#include<iostream>
#include <vector>
#include "bwt_io.h"

#define INT_CEIL(a,b) (a>0? 1+(a-1)/b : 0)

int main(int argc, char** argv) {

    if (argc != 5) {
        std::cout << "usage: ./reverse_bwt file.rlbwt output_file bits n\n\n"
                     "file.rlbwt: the BCR BWT file generated by grlBWT\n"
                     "bits:       maximum number of bits that the runs can use\n"
                     "n:          partition the runs into blocks so that the cumulative sum for the run lengths of each block is precisely n. 0 means no partition\n"
                     "output file: file storing the new encoding for file.rlbwt"<< std::endl;
        exit(0);
    }

    errno = 0;
    std::string input_file = std::string(argv[1]);
    char *endptr;
    long bits = strtol(argv[2], &endptr, 10);
    size_t block_size = strtol(argv[3], &endptr, 10);
    std::string output_file = std::string(argv[4]);
    assert(bits<64);
    size_t max_length= (1UL<<size_t(bits))-1UL;
    std::cout<<"Maximum size allowed for the runs "<<max_length<<std::endl;
    std::cout<<"Block size "<<block_size<<std::endl;


    bwt_buff_reader bwt_reader(input_file);
    size_t sym=0, len=0, tmp_len;

    bwt_buff_writer bwt_writer(output_file,
                               std::ios::out,
                               bwt_reader.bytes_per_rsym(),
                               INT_CEIL(bits, 8));

    std::cout<<"Splitting the runs in the BWT"<<std::endl;
    size_t tot_runs=0, acc_block=0, diff, o_splits=0, b_splits=0;

    for(size_t i=0;i<bwt_reader.size();i++){

        bwt_reader.read_run(i, sym, len);

        while(len>max_length){

            len-=max_length;
            tmp_len=max_length;

            if(block_size>0){
                while((acc_block+tmp_len)>block_size){
                    diff = (acc_block + tmp_len) - block_size;
                    tmp_len -= diff;
                    //append extra run of length tmp_len
                    bwt_writer.push_back(sym, tmp_len);
                    tot_runs++;
                    b_splits++;
                    assert((acc_block + tmp_len) == block_size);

                    tmp_len = diff;
                    acc_block = 0;
                }
            }

            assert((acc_block+tmp_len)<=block_size);
            //append extra run of length tmp_len
            bwt_writer.push_back(sym, tmp_len);
            tot_runs++;
            o_splits++;
            acc_block +=tmp_len;
        }

        assert(len<=max_length);
        if(block_size>0){
            while((acc_block+len)>block_size){
                diff = (acc_block + len) - block_size;
                len -= diff;
                //append extra run of length len
                bwt_writer.push_back(sym, len);
                tot_runs++;
                b_splits++;
                assert((acc_block + len) == block_size);

                len = diff;
                acc_block = 0;
            }
        }

        assert((acc_block+len)<=block_size);
        //append run of length len
        bwt_writer.push_back(sym, len);
        tot_runs++;
        acc_block+=len;
    }
    bwt_reader.close();
    bwt_writer.close();

    std::cout<<"Number of runs before: "<<bwt_reader.size()<<std::endl;
    std::cout<<"Number of runs now: "<<tot_runs<<std::endl;
    std::cout<<"  Overflow splits: "<<o_splits<<" ("<<(double(o_splits)/double(tot_runs))*100<<"%) "<<std::endl;
    std::cout<<"  Block boundary splits: "<<b_splits<<" ("<<(double(b_splits)/double(tot_runs))*100<<"%) "<<std::endl;
    std::cout<<"Increase ratio "<<double(tot_runs)/double(bwt_reader.size())<<std::endl;
    std::cout<<"The new encoding of the BWT was stored in "<<output_file<<std::endl;
}